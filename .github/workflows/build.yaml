# In this workflow, we use a dedicated branch for storing the badges.
# It assumes that the badges branch already exists. That branch can otherwise
# be empty, as its only purpose is to store the coverage badges. Why? Well, if
# our main branch has required checks or reviews, the default GITHUB_TOKEN won't
# be able to push to it. By storing the badges in a dedicated branch, this is not
# an issue (just don't put any required checks or required reviews on the badges
# branch). Note that since we won't be storing anything else in the badges branch,
# we just put them in the root of that branch.
#
# IMPORTANT: Take note of the 2 checkout steps that are necessary for this variation.
# The first is the usual checkout step. The second checks out the dedicated badges branch
# (see the ref input) nested inside of the other in the path badges (see the path input).
# So locally within the rest of this workflow run, we'll have access to the badges branch
# within a badges directory.

name: Build, re-usable
on:
  workflow_call:
    inputs:
      channel:
        required: false
        type: string
        default: 'eresept'
      footer:
        required: false
        type: string
        default: 'eresept Â© 2022'
    secrets:
      webhook:
        required: true
      token:
        required: true

jobs:
  build:
    name: Build ${{ github.event.repository.name }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2 # checks out the ordinary branch
        with:
          fetch-depth: 0
#      - uses: actions/checkout@v2 # checks out the branch that stores the coverage badges
#        with:
#          ref: badges
#          path: badges
      - uses: actions/setup-java@v2
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'

      - name: Start time and timezone
        id: starttime
        run: |
          echo "::set-output name=starttime::$(date +%s)"
          sudo timedatectl set-timezone "Europe/Oslo"

      - name: Get deploy message
        id: deploy-message
        run: |
          echo "::set-output name=commit_msg::$(git log -1 --format=%B)"
          echo "::set-output name=commit_sha::$(git log -1 --format=%H)"

      - name: Create settings.xml
        uses: whelk-io/maven-settings-xml-action@v20
        with:
          repositories: '[{ "id": "github", "name": "github", "url": "https://maven.pkg.github.com/navikt/eresept-parent", "releases": { "enabled": "true" }, "snapshots": { "enabled": "false" } }]'
          servers: '[{ "id": "github", "username": "${{ github.actor }}", "password": "${{ secrets.token }}" }]'

      - name: Compile and test
        run: mvn install

      - name: Jacoco reporting
        uses: navikt/eresept-actions/jacoco-report@v1
        with:
          jacoco-dir: target/site/jacoco

#      - name: Generate JaCoCo Badge
#        uses: cicirello/jacoco-badge-generator@v2
#        with:
#          badges-directory: badges
#          generate-branches-badge: true
#          generate-coverage-badge: true
#          #fail-if-branches-less-than: 0.10
#          #fail-if-coverage-less-than: 0.70
#          jacoco-csv-file: target/site/jacoco/jacoco.csv
#
#      - name: Commit and push the coverage badges
#        if: ${{ github.event_name != 'pull_request' }}
#        run: |
#          cd badges
#          if [[ `git status --porcelain *.svg` ]]; then
#            git config user.name "GitHub Actions Bot (${{ github.actor }})"
#            git config user.email "actions@github.com"
#            git add *.svg
#            git commit -m "Autogenerated JaCoCo coverage badges" *.svg
#            git push
#          fi
#
#      - name: Upload JaCoCo coverage report as a workflow artifact
#        uses: actions/upload-artifact@v2
#        with:
#          name: jacoco-report
#          path: target/site/jacoco/

      - name: Calculate execution time
        id: exectime
        run: |
          END_TIME=$(date +%s)
          echo "::set-output name=exectime::$(( $END_TIME - ${{ steps.starttime.outputs.starttime }} ))"

      - name: Report success?
        if: success()
        env:
          SLACK_CHANNEL: ${{ inputs.channel }}
          SLACK_WEBHOOK: ${{ secrets.webhook }}
          SLACK_USERNAME: "build ${{ github.event.repository.name }}"
          SLACK_TITLE: "Built _*${{ github.event.repository.name }}*_ in ${{ steps.exectime.outputs.exectime }} seconds"
          SLACK_COLOR: "good"
          SLACK_ICON: https://github.com/github.png?size=48
          SLACK_FOOTER: "${{ inputs.footer }}"
          SLACK_MESSAGE: "${{ steps.deploy-message.outputs.commit_msg }}"
        uses: rtCamp/action-slack-notify@v2
      - name: Report failure?
        if: failure()
        env:
          SLACK_CHANNEL: ${{ inputs.channel }}
          SLACK_WEBHOOK: ${{ secrets.webhook }}
          SLACK_USERNAME: "build ${{ github.event.repository.name }}"
          SLACK_TITLE: "Build failure in _*${{ github.event.repository.name }}*_"
          SLACK_COLOR: "danger"
          SLACK_ICON: https://github.com/github.png?size=48
          SLACK_FOOTER: "${{ inputs.footer }}"
          SLACK_MESSAGE: "${{ steps.deploy-message.outputs.commit_msg }}"
        uses: rtCamp/action-slack-notify@v2
      - name: Report cancellation?
        if: cancelled()
        env:
          SLACK_CHANNEL: ${{ inputs.channel }}
          SLACK_WEBHOOK: ${{ secrets.webhook }}
          SLACK_USERNAME: "build ${{ github.event.repository.name }}"
          SLACK_TITLE: "Build of _*${{ github.event.repository.name }}*_ was cancelled"
          SLACK_COLOR: "warning"
          SLACK_ICON: https://github.com/github.png?size=48
          SLACK_FOOTER: "${{ inputs.footer }}"
          SLACK_MESSAGE: "${{ steps.deploy-message.outputs.commit_msg }}"
        uses: rtCamp/action-slack-notify@v2
